---
title: The staged model for the software life cycle
type: flyer
---
* Stage 1: Initial development

Software development starts with an initial development stage where software is built (often from scratch) to satisfy initial requirements. In this stage, the software teams build expertise about the domain and problem, necessities for the evolution of the product. In this phase, creating a good architecture that supports further development is essential. System components need to interact in smart ways, their properties such as functionality and efficiency hinders or helps later development.

* Stage 2: Evolution

Evolutionary stage is defined by iterative changes, modifications and deletion of functionality. These changes occurs because of experienced changes in market needs, legislative actions or business and hardware changes such as expanding a system to changing platforms. Most software development evolves before being shipped, even if many companies choose to ship alfa and beta version to attract customer experiences already during this stage. While making these changes it is important to remember to maintain an open architecture and appropriate, and to keep a competent staff to be able to quickly meet market needs. As long as the software system is kept well­groomed, by competent personnel, it is possible to stay in the evolutionary stage. Often, however, key personnel are shifted to other development projects and less experienced personnel take over. This unfortunately aids in increasing factors like software decay. Gradually changing and hacking at the system leads to an architecture that makes further changes more difficult, and concepts like refactoring and reengineering of large systems inevitably turn expensive. As a result of this, less and less changes are made possible without fear of breaking the existing system. Keeping software in the evolutionary stage is beneficial because it enables changes. It is also expensive because it needs constant vigilance and to be maintained by experienced developers.

* Stage 3: Servicing

When making changes is too expensive and difficult to handle, software enters the servicing stage. It is considered decayed legacy code with an architecture that is too difficult and expensive to change, but it is still seen as important. In this stage only minor changes are made. Software can also be “wrapped” in a black box and left untouched. Some software, like safety-critical software, should never enter the servicing stage as the need for making changes and having control over the software is too important. However, this stage also provides some benefits. As the now legacy software is boxed in, in this allows the use of less experienced personnel to reduce costs. This of course comes at the cost of not being able to follow market trends and other key factors that make your software product competitive. Gradually even minor changes are seen as too difficult to handle.

* Stage 4: Phase­out

As software servicing is discontinued, it enters the phase­out stage. The company may still make money from selling software that isn’t patched, but it will inevitably be too old and fall out of sync with market requirements. During this stage, maintenance and development costs are very low.

* Stage 5: Closedown

In the end, users need to be directed to a new version of the product or alternative solutions. It may be important to provide migration solutions. During the closedown stage there may still be contractual obligations and other factors that mean the code cannot be fully phased out. 

Based on the article "A Staged Model for the Software Life Cycle" by Rajlich and Bennet, 2000
